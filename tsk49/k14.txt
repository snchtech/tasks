Ага, тоді просто: `l_wait_status_id` використовується **як значення, яке ми повертаємо замість фінального**, якщо підпис **ще не останній** у цьому етапі.

Тобто **2 місця**, де вона “працює”:

---

## 1) Усередині `GET_SR_STATUS_F`: у гілці “статус фінальний, але підпис не останній”

Ось ключовий шматок:

```sql
-- якщо базовий статус не фінальний — повертаємо як є
IF NVL(l_is_final, 0) = 0 THEN
  RETURN l_base_status;
END IF;

-- ... тут порахували l_total_in_stage та l_signed_others ...

-- якщо я останній у етапі → дозволяємо фінальний
IF l_signed_others = l_total_in_stage - 1 THEN
  RETURN l_base_status;       -- фінальний статус (наприклад 14)
ELSE
  RETURN l_wait_status_id;    -- НЕ останній → "очікує інших" (15)
END IF;
```

Тобто `l_wait_status_id` — це **альтернатива фінальному статусу**, поки етап ще не завершений усіма підписами.

---

## 2) У місці, де ти вставляєш запис у `SIGNATUREHISTORY`

Там ти нічого окремо з `l_wait_status_id` не робиш — ти просто береш результат функції:

```plsql
l_new_status_id := get_sr_status_f(p_sr_id);

INSERT INTO signaturehistory (
  signright_id,
  new_status_id,
  signer_by,
  signer_date,
  note,
  sdate
) VALUES (
  p_sr_id,
  l_new_status_id,
  :APP_USER,  -- або хто там у тебе
  SYSDATE,
  p_note,
  SYSDATE
);
```

Функція **сама вирішить**, що повернути:

* або фінальний статус етапу (якщо підпис останній),
* або `15` (якщо ще хтось у цьому етапі не підписав).

---

### Якщо хочеш зробити ще зручніше

Можна перетворити `15` на параметр функції (щоб не було “зашито”):

```sql
FUNCTION get_sr_status_f(p_sr_id IN NUMBER, p_wait_status_id IN NUMBER DEFAULT 15)
RETURN NUMBER
```

і тоді замінити `l_wait_status_id` на `p_wait_status_id`. Але це вже опціонально.

Якщо хочеш — скинь фрагмент твого реального `INSERT/UPDATE` при підписі (процедура/тригер), я вставлю ці рядки прямо в твою логіку так, щоб воно стало “копіпаст — і працює”.
