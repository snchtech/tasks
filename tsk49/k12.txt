Ок — тоді ідея така:

1. `DICT_APP_CONFIRM_LIST.status_id` дає **“базовий статус етапу”** для цього `SR`.
2. Ми **не перевіряємо “=14”**, а перевіряємо: *чи є цей базовий статус фінальним* (`MAIN_STATUS.IS_FINAL = 1`).
3. Якщо статус фінальний → робимо перевірку “я останній підпис в етапі чи ні”.
4. Якщо не останній → повертаємо “проміжний” статус (наприклад `15`).

Нижче — оновлений варіант функції, де **фінальність визначається через `MAIN_STATUS.IS_FINAL`**.

> Я припускаю структуру:
>
> * `STATUS (id, main_status_id, ...)`
> * `MAIN_STATUS (id, is_final, ...)`
>   і що `DICT_APP_CONFIRM_LIST.status_id = STATUS.id`.
>
> Якщо у вас інші назви/зв’язки — просто підправте JOIN.

---

## Оновлена функція (IS_FINAL замість “14”)

```sql
CREATE OR REPLACE FUNCTION get_sr_status_f (p_sr_id IN NUMBER)
  RETURN NUMBER
AS
  l_task_id        NUMBER;
  l_subtask_id     NUMBER;
  l_stage_no       NUMBER;   -- номер етапу (DICT.stage)
  l_base_status    NUMBER;   -- DICT.status_id (STATUS.id)

  l_is_final       NUMBER := 0; -- 1/0 з MAIN_STATUS
  l_total_in_stage NUMBER := 0;
  l_signed_others  NUMBER := 0;

  l_wait_status_id CONSTANT NUMBER := 15; -- "очікує інших підписів"
BEGIN
  /* 1) Дістаємо базовий статус + stage */
  SELECT sr.task_id,
         sr.subtask_id,
         d.stage,
         d.status_id
    INTO l_task_id,
         l_subtask_id,
         l_stage_no,
         l_base_status
    FROM TaskTracker.SIGNATURERIGHTS@TO_TASKTRACKER10 sr
    JOIN TaskTracker.DICT_APP_CONFIRM_LIST@TO_TASKTRACKER10 d
      ON d.id = sr.stages_id
   WHERE sr.id = p_sr_id;

  IF l_base_status IS NULL THEN
    RETURN NULL;
  END IF;

  /* 2) Перевіряємо: чи базовий статус фінальний (MAIN_STATUS.IS_FINAL = 1) */
  BEGIN
    SELECT ms.is_final
      INTO l_is_final
      FROM TaskTracker.STATUS@TO_TASKTRACKER10 st
      JOIN TaskTracker.MAIN_STATUS@TO_TASKTRACKER10 ms
        ON ms.id = st.main_status_id
     WHERE st.id = l_base_status;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_is_final := 0;
  END;

  /* 3) Якщо статус не фінальний — повертаємо як є */
  IF NVL(l_is_final, 0) = 0 THEN
    RETURN l_base_status;
  END IF;

  /* 4) Якщо статус фінальний — дозволяємо його тільки якщо це останній підпис в етапі */

  -- скільки всього SR в цьому етапі (групуємо по номеру stage)
  SELECT COUNT(*)
    INTO l_total_in_stage
    FROM TaskTracker.SIGNATURERIGHTS@TO_TASKTRACKER10 sr2
    JOIN TaskTracker.DICT_APP_CONFIRM_LIST@TO_TASKTRACKER10 d2
      ON d2.id = sr2.stages_id
   WHERE sr2.task_id = l_task_id
     AND NVL(sr2.subtask_id, -1) = NVL(l_subtask_id, -1)
     AND d2.stage = l_stage_no;

  -- скільки ІНШИХ SR в цьому етапі вже підписані (є хоча б один запис в SIGNATUREHISTORY)
  SELECT COUNT(*)
    INTO l_signed_others
    FROM TaskTracker.SIGNATURERIGHTS@TO_TASKTRACKER10 sr2
    JOIN TaskTracker.DICT_APP_CONFIRM_LIST@TO_TASKTRACKER10 d2
      ON d2.id = sr2.stages_id
   WHERE sr2.task_id = l_task_id
     AND NVL(sr2.subtask_id, -1) = NVL(l_subtask_id, -1)
     AND d2.stage = l_stage_no
     AND sr2.id <> p_sr_id
     AND EXISTS (
           SELECT 1
             FROM signaturehistory sh
            WHERE sh.signright_id = sr2.id
         );

  /* 5) Якщо всі інші вже підписані — я останній — можна фінальний статус.
        Інакше — повертаємо "очікує інших" (15). */
  IF l_signed_others = l_total_in_stage - 1 THEN
    RETURN l_base_status;      -- фінальний, але тільки для останнього
  ELSE
    RETURN l_wait_status_id;   -- проміжний
  END IF;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END get_sr_status_f;
/
```

---

## Важливий момент про статус “15”

`IS_FINAL` вирішує **коли можна фінальний**, але не каже *який саме статус ставити, якщо не фінальний*.

Найпростіше — як ти й пропонував — **єдиний статус 15 “очікує підтвердження (в межах етапу)”**.

Якщо ж ти хочеш **різні “не-фінальні” статуси для різних етапів**, тоді треба або:

* додати в `DICT_APP_CONFIRM_LIST` колонку `STATUS_ID_NOT_LAST`, або
* зробити окрему таблицю мапінгу `FINAL_STATUS_ID -> NOT_LAST_STATUS_ID`.

Але для старту `15` як універсальний — норм.

---

## Маленька оптимізація (рекомендовано)

Щоб `EXISTS` не гальмував:

* індекс на `SIGNATUREHISTORY(SIGNRIGHT_ID)`.

---

Якщо скинеш структуру твоїх таблиць `STATUS` і `MAIN_STATUS` (назви колонок), я піджену JOIN рівно під твою схему (бо в різних проєктах там буває `STATUS_DICT`, `MAIN_STATUS_ID`, `IS_FINISH`, тощо).
